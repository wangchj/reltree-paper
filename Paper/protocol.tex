
\begin{figure}[!b]
\begin{center}
\includegraphics[width=3.4in]{one-way.eps}
\caption{Anonymous On-Way Protocol.} \label{fig:Stupendous}
\end{center}
\end{figure}

%\vspace*{-10pt}

\subsection{Overview}\label{proto-overview}

In this section, we describe our anonymous One-Way protocol, which
completely removes the ownership and source information from the
sensory data transmitted to the data collection server. Figure 1
illustrates the concept of the theoretical anonymous One-Way
protocol. One-Way is a packet routing protocol similar to the IP
protocol. Data are transmitted in packets. Each packet contains
the address of the destination host so that the packet can be
correctly routed. One major difference between One-Way protocol
and other routing protocols is that, each packet does not include
the routing address of the sender (thus called One-Way). The
source address is intentionally removed so that the receiver of
the data does not know the identity of the sender. In other words,
contractually, the client does not include the source address and
the server will have no access to the source information and thus
keeping the client's identity private. Our protocol is analogous
to sending a parcel through a postal service without sender's
identity and address. An example is sending a hint to the police
pertaining a crime without revealing the sender's identity.

Unlike many other anonymous routing protocols, our protocol does
not involve other peers or mobile devices to transmit the data
payload. This is particular helpful in mobile environments in
which bandwidth is limited. Some privacy aware protocols first
transmit the data payload to several mobile peers several times to
mask the identity of the sender before one of the random peers
transmits the data to the server. This incurs tremendous bandwidth
strain on the peers.

One drawback of a protocol without sender address is that the
sender is unable to get an acknowledgement from the receiver
whether a packet has been received (or lost in transmission). To
solve this problem, One-Way utilizes a peer-to-peer approach to
verify correct transmission of a packet, much like the way
Crowds~\cite{DBLP:journals/tissec/ReiterR98} employs to send data
to a server.

%The peer network is a collection of nodes as in
%Equation~\ref{eq:nodes}

%\begin{equation}\label{eq:nodes}
%\{n_0, n_1, ..., n_h\}
%\end{equation}

For validation of successful transmission, we construct a
peer-to-peer network containing $h$ nodes, where $h$ denotes the
total number of hop counts for control messages pass though. A
peer node is denoted by $n_i$, meaning the $i$-th hop along the
route. We use $n_0$ to denote the originator of the data, and
$n_h$ the last peer that forwards the data to the data collection
server. For control messages travel in the direction from sender
to receiver, a node $n_i$ forwards the message to its successor,
such that $n_i \rightarrow n_{i+1}$. Similarly, for control
messages travel from the receiver back to the sender, a node
forwards the messages to its predecessor, such that $n_{i}
\rightarrow n_{i-1}$. Table~\ref{tab:notations} summarizes the
notations used in this paper.

\begin{table}[h]
\centering \caption{Summary of notations.} \label{tab:notations}
\begin{tabular}{|c|p{2.6in}|}
\hline
{\bf Notation} & {\bf Description}\\
\hline
$n_i$ & A peer node\\
$h$   & Total hop count\\
$I_s$ & Connection identifier of sender\\
$I_r$ & Connection identifier of receiver\\
$A_i$ & Address of the $i$th node\\
$A_r$ & Address of the receiver \\
$D$   & Data payload\\
$s_i$ & The $i$th sequence number; $s_0$ being the initial sequence number\\
$c$   & Connection control message\\
$a$   & Acceptance control message\\
$p$   & Data payload packet\\
$k$   & Acknowledgement control message\\
\hline
\end{tabular}
\end{table}

Opponents may think that since the protocol resides on the network
layer (layer 3), the source address could still be contained in
the lower layer, e.g., the data link layer (layer 2). We argue
that the source link address is different for each hop on the
route, and a route could easily contain 20 hops; therefore the
probability of tracing the link layer packet back to the original
host is very low.

\subsection{Anonymous Connection}\label{anonymous_connection}

Before transmitting data to a data collection server (receiver),
the sender makes an anonymous connection request to the server.
The purpose of the connection request is to establish a peer-based
route on which acknowledgements of data transmission can be sent.

The sender initiates a connection by constructing an anonymous
connection request message, $c$. A request message contains the
connection identifer $I_s$, routing address (or identification),
$A_r$, of the receiver, initial sequence number $s_0$, and a hop
count, $h$. The structure of the request message is defined in
Equation~\ref{eq:con_req_format}

\begin{equation}\label{eq:con_req_format}
c = \{I_s, A_r, h\}, h \geq 1
\end{equation}

In the connection request packet, $h$ is a random natural number
denoting the number of peers the request should be forwarded to
before the request is sent to the server. The connection
identifier $I_s$ is randomly generated, which only lasts for the
session and does not identify a host.

After the sender has constructed the connection request message,
she sends the message to one of her peers running the protocol.
When the peer receives the request, it decreases the hop count $h$
by 1. If the hop count reaches 0, then the peer sends the request
to the server; else, the peer forwards the request to another one
of its peers. Note that a peer (node) does not have to be a pure
peer, but a node in the system whose job is to facilitate
communications for user nodes. Each peer in the route keeps track
of the peer before and after for each request in order to maintain
the route information. If a peer declines a $c$ message, the peer
finds another peer. At the end of the connection phase, the
peer-to-peer route should be constructed such that

\begin{equation}
sender(n_0) \rightarrow n_1 \rightarrow ... \rightarrow n_h
\rightarrow receiver
\end{equation}

When the server receives the connection request, it sends back an
acceptance message $a$ to the node ($n_h$) from which it receives
the connection request. The acceptance message contains a
connection token $I_r$, as well as the request identifier from the
sender, $I_s$. The format of the acceptance message is defined in
Equation~\ref{eq:con_accept_format}

\begin{equation}\label{eq:con_accept_format}
a = \{I_r, I_s\}
\end{equation}

The node that receives the acceptance message from the receiver
forwards the message in reverse to the peer who forwarded the
request message. Each peer in the route keeps the route
information based on $I_s$ and the acceptance messages travels in
revers on the same route until the message reaches the original
sender.

%[Discussion of the security of this connection approach]

%[Briefly describe routing table format and management for example, there
%is no activity for a connection for a long time. What should be done?]

\subsection{Payload Transmission}

Payload is the actual data transmitted to the server. In
participatory sensing, this is the data collected by mobile
devices from the environment and include sensor data, photos,
videos, etc. Payload transmission does not involve peers since
peer-forwarding in wireless mobile environment is expensive;
instead, payloads are transmitted through the One-Way network, in
which the packets only contain the receiver address and
identification.

The payload transmission begins when the sender receives the
acceptance message from the server. In addition to the payload
$D$, a payload packet, denoted with $p$, also contains the address
of of the receiver $A_r$, the connection identifier $I_r$, and a
sequence number $s_i$. The format is defined in
Equation~\ref{eq:payload_format}.

\begin{equation}\label{eq:payload_format}
p = \{A_r, I_r, s_i, D\}
\end{equation}

$I_r$ is the identifier issued by the server received from the
connection acceptance message. The purpose of this identifier is
for the server to identify a particular data transmission. For
example, the server could be receiving several data transmissions
simultaneously from different clients each transmits a file. The
server assigns an identifier $I_r$ to each transmission to
differentiate the packets for different transmissions. This field
is analogous to the port numbers in the transport layer such as
TCP and UDP to multiplex packets for different connections and
applications.

The sequence number $s_i$ in a payload packet identifies
individual packets for a transmission. The sequence numbers
provide the order of the packets and allow the receiver to
identify if a packet is lost in the network, or if packets arrived
out of order.

The purpose of the connection establishment step before payload
transmission is to establish a channel in which the mobile client
can verify that a packet has been successfully received by the
server. Techniques of reliable data transfer in unreliable
channels is out of the scope of this paper. Reliable data transfer
mechanisms employed in TCP~\cite{RFC793} and theoretical
techniques such as GO-Back-N and Select Repeat~\cite{book:Kurose}
can be employed with our design. In addition, when the server
sends the status of a packet back to the client, it sends the
status message through the peer-to-peer channel established during
connection establishment. In other words, after receiving a
payload packet $p$, the server sends an acknowledgement message,
$k$, to the node from which it received the connection request
(also the node to which it sends the connect acceptance message).
Since all nodes on the anonymous route memorize the previous node
based on the connection identifiers, $I_s$ and $I_r$, each node
forwards $k$ to its previous peer until the message reaches the
originator of $p$.

%\begin{figure}[h]
%\begin{center}
%\includegraphics[width=3in]{arch.eps}
%\caption{\small \sl System Architecture.\label{fig:Stupendous}}
%\end{center}
%\end{figure}

\subsection{Node Disconnection and Failure}

When a node can no longer service a route for a connection due to
resource constraint or node shutting down, the disconnecting node
(denoted by $n_d$) should notify its neighboring nodes of such
event so that the interruption of a connection and of delivering
of control messages can be minimized. In this section, we focus on
disconnecting a single connection (as in the case of resource
constraint). If a node wishes to disconnect all connections it
supports (as in the case of node shutdown), $n_d$ performs a
disconnection process discussed in this section for each
connection.

There are two scenarios for $n_d$: the next node is an
intermediate node, and $n_d$ is the last node in the route ($d$ =
$h$). For the first case in which $n_d$ is an intermediate node
and the next node is also an intermediate node, $n_d$ should
simply bridge the gap and withdraw from the route. In this case,
$n_d$ sends the node before $n_{d-1}$ and after $n_{d+1}$ it a
disconnection message containing the identity (the address) of the
two nodes. Once the connection between the two nodes has been
established, $n_d$ can remove the route information for the
connection from its routing table.

In the second case, $n_d$ is the last node of the route and
communicates directly with the server. In this case, we do not
want just bridge the two nodes $n_{d-1}$ and $n_{d+1}$ since
$n_{d-1}$ could be the originator of the data. In order to
establish a new route for the connection, $n_d$ sends a
disconnection message to and telling the server that a new control
message route will be constructed for this connection. $n_d$ also
sends a route discovery message to $n_{d-1}$ and telling the node
to construct a new route to the server. $n_{d-1}$ follows the same
steps described in section~\ref{anonymous_connection} to establish
a new connection to the server. The disconnection algorithm is
detailed in Algorithm~\ref{alg:disconnect}.

\begin{algorithm}
\algsetup{linenodelimiter=. } \caption{disconnect($n_d$)}
\label{alg:disconnect}
\begin{algorithmic}[1]
\IF{$A_d$ == $A_h$}
    \STATE $m_1$ = DisconnectMessage($I_s$, $I_r$)
    \STATE $m_2$ = RediscoveryMessage($I_s$, $I_r$)
    \STATE SendToNode($A_r$, $m_1$)
    \STATE SendToNode($A_{d-1}$, $m_2$)
\ELSE
    \STATE $m_1$ = BridgeMessage($Forward$, $A_{d+1}$, $I_s$, $I_r$)
    \STATE $m_2$ = BridgeMessage($Backward$, $A_{d-1}$, $I_s$, $I_r$)
    \STATE SendToNode($A_{d-1}$, $m_1$)
    \STATE SendToNode($A_{d+1}$, $m_2$)
\ENDIF
\end{algorithmic}
\end{algorithm}

%linenosize=\small,

In the event of unforeseen failure of a node, such as power or
network failure, the disconnected node $n_d$ is unable to notify
its neighbors on a route before disconnecting. When this happens
the first thing that the sender will notice is that she no longer
receives acknowledgement messages of received packets from the
server. To test for node failure in the path, the sender can send
a route test message into the route. When a node $n_m$ receives
the test message, it sends an acknowledgement back to its
predecessor $n_{m-1}$ on the route and forwards the test message
to its successor $n_{m+1}$ on the route. If an intermediate node
on the route $n_f$ cannot be contacted or does not acknowledge the
test message, then its predecessor $n_{f-1}$ sends a failure
notice backward through the route to notify the sender a failure
has been detected. $n_{f-1}$ uses the route discovery algorithm to
discovery a new route from $n_{f-1}$ to the server and notify the
new route has been successfully established. In the case that
there is no failure detected, but the sender still does not
receive acknowledgements from the server, the sender can select to
terminate the data transmission and peer connection.

\subsection{Connection Tear-Down}

After the entire file has been sent to and received by the server,
the sender can choose to tear down the connection so that the
nodes can free the resources used for the connection. To terminate
a connection, the sender injects the termination message
identified by $I_s$ and $I_r$ into the connection. Upon receiving
the termination message, a node forwards the message to its
successor and frees any resource associated with the connection.
Eventually the termination message reaches the server. The server
frees the resources and stores the received file.
